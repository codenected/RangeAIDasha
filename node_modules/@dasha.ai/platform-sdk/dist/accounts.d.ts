/// <reference types="node" />
import type * as http from "http";
/**
 * Account information.
 *
 * This data is stored in an OS-specific config file directory.
 */
export interface AccountInfo {
    /** An endpoint to use for Dasha APIs */
    server: string;
    /** An API key to use for Dasha APIs */
    apiKey: string;
    /** Whether to use non-TLS-encrypted connections */
    insecure?: true;
}
/**
 * Get all stored accounts.
 *
 * @param options.configDir overrides the config file location
 */
export declare function getAccounts(options?: {
    configDir?: string;
}): Promise<{
    [accountName: string]: AccountInfo;
}>;
/**
 * Get stored information for a specific account. Throws an error if no account was found.
 *
 * @param accountName which account to get the info for
 * @param options.configDir overrides the config file location
 */
export declare function getAccountInfo(accountName: string, options?: {
    configDir?: string;
}): Promise<AccountInfo>;
/**
 * Store the information for a specific account.
 *
 * @param accountName which account to set the info for
 * @param info the info to store
 * @param options.overwrite whether to throw an error if the account already exists
 * @param options.configDir overrides the config file location
 */
export declare function setAccountInfo(accountName: string, info: AccountInfo, options?: {
    overwrite?: boolean;
    configDir?: string;
}): Promise<void>;
/**
 * Rename a stored account.
 *
 * @param oldAccountName the account to rename
 * @param newAccountName new account name
 * @param options.overwrite whether to throw an error on name conflict
 * @param options.configDir overrides the config file location
 */
export declare function renameAccount(oldAccountName: string, newAccountName: string, options?: {
    overwrite?: boolean;
    configDir?: string;
}): Promise<void>;
/**
 * Remove a stored account.
 *
 * @param accountName the account to remove
 * @param options.quiet whether to throw an error if the account does not exist
 * @param options.configDir overrides the config file location
 */
export declare function removeAccount(accountName: string, options?: {
    quiet?: boolean;
    configDir?: string;
}): Promise<void>;
/**
 * Get the name of an account that is set as current, or `undefined` if no current account is set.
 *
 * @param options.configDir overrides the config file location
 */
export declare function getCurrentAccountName(options?: {
    configDir?: string;
}): Promise<string | undefined>;
/**
 * Set a specific stored account as current. Throws an error if no account with such name exists.
 *
 * @param accountName the account to set as current
 * @param options.configDir overrides the config file location
 */
export declare function setCurrentAccountName(accountName: string | undefined, options?: {
    configDir?: string;
}): Promise<void>;
/**
 * Get stored information for the account set as current. Throws an error if there is no current account.
 *
 * @param options.configDir overrides the config file location
 */
export declare function getCurrentAccountInfo(options?: {
    configDir?: string;
}): Promise<AccountInfo>;
/**
 * Authorize a user of the Dasha platform.
 *
 * When `callback` is called, it should open the provided `authUrl` in a browser window.
 * There will be a login form that, when the user logs in, redirects them to `redirectUri`.
 * It should then return the fragment (hash) part of the URI.
 *
 * @param options.server an endpoint to use for Dasha APIs
 * @param options.insecure whether to user non-TSL-encrypted connections
 */
export declare function authorize(options: {
    server: string;
    insecure?: boolean;
    redirectUri: string;
    responseType: "fragment";
    callback: (authUrl: string) => Promise<string>;
}): Promise<AccountInfo>;
/**
 * Authorize a user of the Dasha platform.
 *
 * When `callback` is called, it should open the provided `authUrl` in a browser window.
 * There will be a login form that, when the user logs in, redirects them to `redirectUri`.
 * The caller must listen at the provided URI with an HTTP server and return the first request that comes.
 *
 * @param options.server an endpoint to use for Dasha APIs
 * @param options.insecure whether to user non-TSL-encrypted connections
 */
export declare function authorize(options: {
    server: string;
    insecure?: boolean;
    redirectUri: string;
    responseType: "form";
    callback: (authUrl: string) => Promise<http.IncomingMessage>;
}): Promise<AccountInfo>;
export declare function startTrial(options: {
    server: string;
    insecure?: boolean;
}): Promise<AccountInfo>;
