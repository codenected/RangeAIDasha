/// <reference types="node" />
import { Writable } from "stream";
import * as rxjs from "rxjs";
import { DashaSdkError } from "./errors";
import { GroupSettingsManager } from "./group-settings";
import { CustomIntents, INluServiceCreationRequest } from "./nlu-service";
import { ProgressReporter } from "./progress";
import { SessionConfig } from "./session-config";
import { SipSettingsManager } from "./sip-settings";
import { TtsManager } from "./tts";
import * as logger from "./logger";
export interface Options {
    sendErrorReports?: boolean;
    logLevel?: string;
    logger?: logger.Logger;
}
export declare function configure(options: Options): void;
/**
 * @todo: add link
 */
export declare class DashaSdk {
    private readonly server;
    private readonly apiKey?;
    private readonly insecure;
    readonly sipSettings: SipSettingsManager;
    readonly groupSettings: GroupSettingsManager;
    readonly tts: TtsManager;
    /**
     * @param options.server Dasha platform server to use
     * @param options.url Deprecated. Use `options.server` instead.
     * @param options.apiKey API key of the Dasha platform.
     * @param options.insecure Set to true to not use TLS
     */
    constructor(options: {
        server?: string;
        url?: string;
        apiKey: string;
        insecure?: boolean;
    });
    registerApp(options: {
        groupId?: string;
        concurrency: number;
        progressReporter?: ProgressReporter;
    } & ({
        appPackage: Uint8Array;
    } | {
        appPackage?: undefined;
        appPackagePath: string;
    })): Promise<IApplication>;
    /**
     * Provide a chat connection for a specific job.
     *
     * @param platformJobId Platform-assigned ID of a job.
     *
     * @example
     * ```ts
     * const job = await app.startJob(data);
     * const chat = await dasha.connectChat(job.platformJobId)
     * ```
     */
    connectChat(platformJobId: string): Promise<IChatChannel>;
    createNluService(customIntents?: CustomIntents): INluServiceCreationRequest;
    /**
     * Download the audio recording of the past job
     *
     * @param record - record to download
     * @param filename - name to record in file system
     */
    downloadRecord(record: AudioRecord, filename: string): Promise<void>;
    /**
     * Download the audio recording of the past job
     *
     * @param record - record to download
     * @param stream - configured writable stream for saving audio recording
     * @see https://nodejs.org/api/stream.html#stream_class_stream_writable
     */
    downloadRecord(record: AudioRecord, stream: Writable): Promise<void>;
    private createClient;
}
/**
 * @todo: add link
 */
export interface AudioRecord {
    /**
     * A platform-assigned ID of the job audio record.
     */
    readonly recordId: string;
}
/**
 * @todo: add link
 */
export interface IChatChannel {
    /**
     * An Observable of the messages received from the application.
     *
     * @see https://rxjs.dev/api/index/class/Observable
     */
    readonly receivedMessages: rxjs.Observable<string>;
    /**
     * Send a message to the application.
     *
     * @param text - Text of the message.
     */
    sendMessage(text: string): Promise<void>;
    /**
     * End the chat and close the channel.
     */
    close(): Promise<void>;
    /**
     * State of the channel.
     */
    readonly closed: boolean;
}
/**
 * A handler for the job lifecycle events.
 *
 * @todo: add link
 */
export interface IJobEventHandler {
    /**
     * A callback triggered when the platform is ready to start the next job.
     *
     * @param platformJobId A platform-assigned ID of the job.
     * @param clientJobId A client-assigned ID of the job.
     * @param incomingData Data from incoming connections.
     *
     * @returns Whether to accept or reject a job, and how to handle it.
     */
    startingJob(platformJobId: string, clientJobId: string, incomingData: Record<string, unknown>): Promise<StartingResult>;
    /**
     * A callback triggered when the task did not have time to start before the deadline.
     *
     * @param clientJobId A client-assigned ID of the job.
     */
    timedOutJob?(clientJobId: string): Promise<void>;
    /**
     * A callback triggered when the job has failed.
     *
     * @param clientJobId A client-assigned ID of the job.
     * @param error Reason of job failure.
     */
    failedJob(clientJobId: string, error: DashaSdkError, records: AudioRecord[]): Promise<void>;
    /**
     * A callback triggered when the job has been completed successfully.
     *
     * @param clientJobId A client-assigned ID of the job.
     * @param result The output of the application.
     */
    completedJob(clientJobId: string, result: Record<string, unknown>, records: AudioRecord[]): Promise<void>;
}
/**
 * Definitions of external functions that can be called by the application.
 *
 * @example
 * ```ts
 * // DSL signature:
 * // external function foo(x: number, y: string): string;
 * const handler = { foo: async ({ x, y }) => `${x}, ${y}` }
 * ```
 */
export declare type RpcHandler = Record<string, (args: Record<string, unknown>) => Promise<unknown>>;
/**
 * A handler for the job debug events.
 */
export interface IDebugEvents {
    /**
     * A callback triggered when the application requests to write a debug log.
     *
     * @param msg Log message.
     *
     * @see `#log()` system call
     * @todo: add link
     */
    log?(msg: string): Promise<void>;
    /**
     * A callback for the dialogue transcription.
     *
     * @param msg Message text.
     * @param incoming `false` for messages from the application.
     */
    transcription?(msg: string, incoming: boolean, extra: {
        startTime: Date;
        endTime: Date;
    }): Promise<void>;
}
/**
 * A value indicating whether the SDK client accepts the starting job,
 * as well as how to handle it.
 *
 * @see {@link IJobEventHandler.startingJob}
 */
export declare type StartingResult = RejectStartingResult | AcceptStartingResult;
/**
 * A value indicating that the job is to be rejected and removed from the queue.
 *
 * @see {@link IJobEventHandler.startingJob}
 */
export declare type RejectStartingResult = {
    /**
     * The job is to be rejected.
     */
    accept: false;
};
/**
 * A value indicating that the job is to be accepted, as well as how to handle it.
 */
export declare type AcceptStartingResult = {
    /**
     * The job is to be accepted.
     */
    accept: true;
    /**
     * Name of the session config with which the job will be executed.
     */
    sessionConfigName: string;
    /**
     * Input data object (initial context) of the application.
     */
    data: Record<string, unknown>;
    /**
     * Definitions of external functions that can be called by the application.
     */
    rpcHandler?: RpcHandler;
    /**
     * A handler for the job debug events.
     */
    debugEvents?: IDebugEvents;
};
/**
 * Description of the job to be enqueued for execution.
 *
 * @todo: add link
 */
export interface IJobDescription {
    /**
     * A client-assigned ID of the job.
     */
    id: string;
    /**
     * The earliest point in time the job can be started.
     */
    notBefore?: Date;
    /**
     * The latest point in time the job can be started.
     *
     * @remarks
     * If the job cannot be started in time, IJobHandler.timedOutJob will be called.
     */
    notAfter: Date;
    /**
     * How quickly will the job be processed in the job queue. An integer from 0 to 7.
     *
     * @default 0
     */
    priority?: number;
}
/**
 * Description of the location of the session config or description of the session config itself.
 *
 * @property name Config name
 * @property configPath File system path to a config JSON file.
 * @property config Session config.
 */
export declare type SessionConfigOptions = {
    name?: string;
    configPath: string;
    config?: undefined;
} | {
    name?: string;
    config: SessionConfig;
};
export declare type StartJobOptions = {
    /**
     * Input data object (initial context) of the application.
     */
    data: Record<string, unknown>;
    /**
     * Definitions of external functions that can be called by the application.
     */
    rpcHandler?: RpcHandler;
    /**
     * A handler for the job debug events.
     */
    debugEvents?: IDebugEvents;
};
/**
 * A job launched by IApplication.startJob()
 *
 * @todo: add link
 */
export interface IJob {
    /**
     * A client-assigned ID of the job.
     */
    readonly id: string;
    /**
     * A platform-assigned ID of the job.
     */
    readonly internalId: string;
    /**
     * The output of the application.
     */
    readonly result: Promise<Record<string, unknown>>;
    readonly records: Promise<AudioRecord[]>;
}
export interface VoiceInfo {
    /**
     * Speaker used for pronunciation
     *
     * For [Google TTS], this translates into the "Voice name" field, e.g. `"en-US-Wavenet-H"`.
     *
     * [Google TTS]: https://cloud.google.com/text-to-speech/docs/voices
     */
    speaker: string;
    /**
     * Pronunciation language
     *
     *  For [Google TTS], this is expressed as BCP-47 language tags (e.g. `"en-US"`, `"es-419"`, `"cmn-tw"`).
     *
     * [Google TTS]: https://cloud.google.com/text-to-speech/docs/reference/rpc/google.cloud.texttospeech.v1#voice
     */
    language: string;
    /**
     * Emotion of text pronunciation.
     *
     * @example
     * "Neutral", "Good", "Evil", etc.
     */
    emotion: string;
    /**
     * Playback speed multiplier relative to base speed. Must be non-negative.
     *
     * For [Google TTS], this gets passed as the `speaking_rate` field.
     *
     * [Google TTS]: https://cloud.google.com/text-to-speech/docs/reference/rpc/google.cloud.texttospeech.v1#audioconfig
     */
    speed: number;
    /**
     * Unique variant of the pronunciation of phrases, provided that the text and other parameters of voiceInfo match.
     * Non-negative integer.
     *
     * @default 0
     */
    variation: number;
}
/**
 * Audio data and format for external TTS
 * Supported formats: wav, mp3, pcm16
 */
export interface TtsResponse {
    audioFormat: string;
    audioData: Uint8Array;
}
/**
 * A registered dialogue application.
 *
 * @todo: add link
 */
export interface IApplication {
    /**
     * Unique identifier of the application. Same for all application instances.
     *
     * @example
     * ```ts
     * const app1 = await dasha.registerApplication(...args);
     * const app2 = await dasha.registerApplication(...args);
     * assert(app1.applicationId === app2.applicationId)
     * ```
     */
    readonly applicationId: string;
    /**
     * Unique identifier of the application instance.
     */
    readonly instanceId: string;
    /**
     * An observable of SDK errors.
     *
     * @see https://rxjs.dev/api/index/class/Observable
     */
    readonly errors: rxjs.Observable<DashaSdkError>;
    /**
     * Put jobs into the execution queue.
     *
     * @param jobs A set of job descriptions to be queued for execution
     */
    enqueueJobs(jobs: IJobDescription[]): Promise<void>;
    /**
     * Set the event handler for jobs coming from the Dasha platform.
     */
    onJob(jobEventHandler: IJobEventHandler): void;
    /**
     * Start a single job.
     *
     * @remarks
     *
     * @param clientJobId A client-assigned ID of the job.
     * @param sessionConfigName Name of the session config with which the job will be executed.
     * @param options Additional job parameters.
     */
    startJob(clientJobId: string, sessionConfigName: string, options: StartJobOptions): Promise<IJob>;
    /**
     * Add a session configuration to the application.
     *
     * @todo docs link
  
     * @param options Session config options.
     */
    addSessionConfig(options: SessionConfigOptions): Promise<string>;
    /**
     * Set a logger for an application instance.
     *
     * @param logger - https://nodejs.org/api/console.html
     */
    setLogger(logger: Console): void;
    /**
     * Set a tts handler for an external client tts service
     * @param handler external client audio handler which is callen when server put message to stream
     * Handler params:
     * @param text to convert to speech
     * @param voiceInfo additional information about text
     * @returns response that contains audio format and data
     */
    setTtsHandler(handler?: (text: string, voiceInfo: VoiceInfo) => Promise<TtsResponse>): void;
    /**
     * Disconnect the application.
     */
    disconnect(): void;
}
