"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SipSettingsManager = void 0;
const querystring = __importStar(require("querystring"));
const axios_1 = __importDefault(require("axios"));
const errors_1 = require("./errors");
const logger = __importStar(require("./logger"));
class SipSettingsManager {
    constructor(options) {
        // TODO: optimize work with the Rest API #732
        this._client = axios_1.default.create({
            baseURL: (options.insecure ? "http://" : "https://") + options.server,
            headers: {
                Authorization: `Bearer ${options.apiKey}`,
                "Content-Type": "application/json",
            },
            paramsSerializer: querystring.stringify,
            responseType: "json",
        });
        this._client.interceptors.response.use(undefined, (error) => {
            var _a, _b, _c, _d, _e, _f, _g;
            const validationErrors = (_b = (_a = error.response) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.errors;
            if (validationErrors !== undefined) {
                const messages = Object.values(validationErrors).flat().join(" ");
                return Promise.reject(new errors_1.DashaSdkError(messages, error));
            }
            const errorDetails = (_d = (_c = error.response) === null || _c === void 0 ? void 0 : _c.data) === null || _d === void 0 ? void 0 : _d.details;
            if (errorDetails !== undefined) {
                return Promise.reject(new errors_1.DashaSdkError(errorDetails, error));
            }
            const errorReason = (_f = (_e = error.response) === null || _e === void 0 ? void 0 : _e.data) === null || _f === void 0 ? void 0 : _f.reason;
            if (errorReason !== undefined) {
                return Promise.reject(new errors_1.DashaSdkError(errorReason, error));
            }
            const statusText = (_g = error.response) === null || _g === void 0 ? void 0 : _g.statusText;
            if (statusText !== undefined) {
                return Promise.reject(new errors_1.DashaSdkError(statusText, error));
            }
            return Promise.reject(new errors_1.DashaSdkError(error.message, error));
        });
    }
    async _getSipEndpoints() {
        return (await this._client.get(`/api/v1/sip/endpoint`)).data;
    }
    async _postSipEndpoint(body) {
        return (await this._client.post(`/api/v1/sip/endpoint`, body)).data;
    }
    async _patchSipEndpoint(id, body) {
        return (await this._client.patch(`/api/v1/sip/endpoint/${id}`, body)).data;
    }
    async _deleteSipEndpoint(id) {
        await this._client.delete(`/api/v1/sip/endpoint/${id}`);
    }
    async _getSipOutbound() {
        return (await this._client.get(`/api/v1/sip/outbound`)).data;
    }
    async _postSipOutbound(body) {
        return (await this._client.post(`/api/v1/sip/outbound`, body)).data;
    }
    async _patchSipOutbound(id, body) {
        await this._client.patch(`/api/v1/sip/outbound/${id}`, body);
    }
    async _deleteSipOutbound(id) {
        await this._client.delete(`/api/v1/sip/outbound/${id}`);
    }
    async createInbound(name, config) {
        return logger.catchErrorsAsync(logger.create(), async () => {
            var _a, _b, _c, _d;
            return await this._postSipEndpoint({
                name,
                applicationName: config.applicationName,
                password: (_a = config.password) !== null && _a !== void 0 ? _a : null,
                ipACLs: (_b = config.ipAcls) !== null && _b !== void 0 ? _b : null,
                priority: (_c = config.priority) !== null && _c !== void 0 ? _c : null,
                groupId: (_d = config.groupId) !== null && _d !== void 0 ? _d : null,
            });
        });
    }
    async listInbound() {
        return logger.catchErrorsAsync(logger.create(), async () => {
            const response = await this._getSipEndpoints();
            return response.map((x) => {
                var _a;
                return ({
                    id: x.id,
                    name: x.name,
                    ipAcls: (_a = x.ipACLs) !== null && _a !== void 0 ? _a : undefined,
                    applicationName: x.applicationName,
                    customerId: x.customerId,
                    priority: x.priority,
                    groupId: x.groupId,
                    uri: x.uri,
                });
            });
        });
    }
    async updateInbound(name, configPatch) {
        return logger.catchErrorsAsync(logger.create(), async () => {
            const endpoints = await this._getSipEndpoints();
            const endpointToPatch = endpoints.find((x) => x.name === name);
            if (endpointToPatch === undefined) {
                throw new errors_1.DashaSdkError(`inbound config not found: ${name}`);
            }
            await this._patchSipEndpoint(endpointToPatch.id, {
                applicationName: configPatch.applicationName,
                password: configPatch.password,
                ipACLs: configPatch.ipAcls,
                priority: configPatch.priority,
                groupId: configPatch.groupId,
            });
        });
    }
    async deleteInbound(name) {
        return logger.catchErrorsAsync(logger.create(), async () => {
            const endpoints = await this._getSipEndpoints();
            const endpointToDelete = endpoints.find((x) => x.name === name);
            if (endpointToDelete === undefined) {
                throw new errors_1.DashaSdkError(`inbound config not found: ${name}`);
            }
            await this._deleteSipEndpoint(endpointToDelete.id);
        });
    }
    async createOutbound(name, config) {
        return logger.catchErrorsAsync(logger.create(), async () => {
            var _a, _b;
            return await this._postSipOutbound({
                name,
                server: config.server,
                domain: (_a = config.domain) !== null && _a !== void 0 ? _a : null,
                transport: config.transport,
                account: config.account,
                password: (_b = config.password) !== null && _b !== void 0 ? _b : null,
            });
        });
    }
    async listOutbound() {
        return logger.catchErrorsAsync(logger.create(), async () => {
            const response = await this._getSipOutbound();
            return response.map((x) => {
                var _a, _b;
                return ({
                    id: x.id,
                    customerId: x.customerId,
                    name: x.name,
                    server: x.server,
                    domain: (_a = x.domain) !== null && _a !== void 0 ? _a : undefined,
                    transport: x.transport,
                    account: x.account,
                    sourceIps: (_b = x.sourceIPs) !== null && _b !== void 0 ? _b : undefined,
                });
            });
        });
    }
    async updateOutbound(name, configPatch) {
        return logger.catchErrorsAsync(logger.create(), async () => {
            const outbound = await this._getSipOutbound();
            const outboundToPatch = outbound.find((x) => x.name === name);
            if (outboundToPatch === undefined) {
                throw new errors_1.DashaSdkError(`outbound config not found: ${name}`);
            }
            await this._patchSipOutbound(outboundToPatch.id, {
                server: configPatch.server,
                domain: configPatch.domain,
                transport: configPatch.transport,
                account: configPatch.account,
                password: configPatch.password,
            });
        });
    }
    async deleteOutbound(name) {
        return logger.catchErrorsAsync(logger.create(), async () => {
            const outbound = await this._getSipOutbound();
            const outboundToDelete = outbound.find((x) => x.name === name);
            if (outboundToDelete === undefined) {
                throw new errors_1.DashaSdkError(`outbound config not found: ${name}`);
            }
            await this._deleteSipOutbound(outboundToDelete.id);
        });
    }
}
exports.SipSettingsManager = SipSettingsManager;
//# sourceMappingURL=sip-settings.js.map