"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert = __importStar(require("assert"));
const luxon = __importStar(require("luxon"));
const logger = __importStar(require("./logger"));
function toArray(items) {
    if (items === undefined)
        return [];
    if (Array.isArray(items))
        return items;
    return [items];
}
function valueOrCallback(valueOrCallback, ...args) {
    if (typeof valueOrCallback === "function") {
        return valueOrCallback(...args);
    }
    return valueOrCallback;
}
function toInterval(dates) {
    const from = typeof dates === "string" ? dates : dates.from;
    const to = typeof dates === "string" ? dates : dates.to;
    const start = luxon.DateTime.fromISO(from);
    const end = luxon.DateTime.fromISO(to).plus({ days: 1 });
    if (!start.isValid) {
        throw new Error(`invalid date format: ${JSON.stringify(from)}`);
    }
    if (!end.isValid) {
        throw new Error(`invalid date format: ${JSON.stringify(to)}`);
    }
    return luxon.Interval.fromDateTimes(start, end);
}
function toDays(interval) {
    const result = [];
    const { start, end } = interval;
    for (let dateTime = start; dateTime < end; dateTime = dateTime.plus({ days: 1 })) {
        result.push(dateTime);
    }
    return result;
}
function parseHour(hour) {
    const matches = /^(\d{1,2}):(\d{1,2})(?:(\d{1,2}))?$/.exec(hour);
    try {
        assert.ok(matches !== null);
        const hours = parseInt(matches[1]);
        assert.ok(0 <= hours && hours <= 24);
        const minutes = parseInt(matches[2]);
        assert.ok(0 <= minutes && minutes <= 59);
        const seconds = matches[3] !== undefined ? parseInt(matches[3]) : undefined;
        assert.ok(seconds === undefined || (0 <= seconds && seconds <= 59));
        return { hour: hours, minute: minutes, second: seconds };
    }
    catch (e) {
        throw new Error(`invalid hour format: ${JSON.stringify(hour)}`);
    }
}
function withHours(dateTime, hours) {
    const start = dateTime.set(parseHour(hours.from));
    const end = dateTime.set(parseHour(hours.to));
    return luxon.Interval.fromDateTimes(start, start <= end ? end : end.plus({ days: 1 }));
}
function parseTimezone(tz) {
    if (typeof tz === "number")
        return luxon.FixedOffsetZone.instance(tz);
    return tz;
}
function withTimezone(interval, tz) {
    const start = interval.start.setZone(parseTimezone(tz), { keepLocalTime: true });
    const end = interval.end.setZone(parseTimezone(tz), { keepLocalTime: true });
    if (!start.isValid || !end.isValid) {
        throw new Error(`invalid timezone: ${JSON.stringify(tz)}`);
    }
    return luxon.Interval.fromDateTimes(start, end);
}
/**
 * A scheduler to augment job data with the {@link IJobDescription.notBefore}
 * and {@link IJobDescription.notAfter} attributes according to set rules.
 *
 * @example
 * const scheduler = new Scheduler()
 *   .dates({ from: "2020-09-01", to: "2020-09-20" })
 *   .hours({ from: "20:00", to: "22:00" })
 *   .timezone(data => data.tz);
 *
 * application.enqueueJobs([scheduler.schedule(jobData)]);
 */
class Scheduler {
    dates(...args) {
        if (args.length === 0)
            return this;
        if (typeof args[0] === "function") {
            this._dates = args[0];
            return this;
        }
        this._dates = args;
        return this;
    }
    hours(...args) {
        if (args.length === 0)
            return this;
        if (typeof args[0] === "function") {
            this._hours = args[0];
            return this;
        }
        this._hours = args;
        return this;
    }
    timezone(tz) {
        this._timezone = tz;
        return this;
    }
    /**
     * Find the next available time interval for a job.
     *
     * @param data Job data
     * @param options Additional options
     *
     * @returns A job description to pass to {@link Application.enqueueJobs}
     */
    schedule(data, options = {}) {
        return logger.catchErrors(logger.create(), () => {
            var _a, _b;
            if (this._dates === undefined) {
                throw new Error(`dates() must be set`);
            }
            if (this._hours === undefined) {
                throw new Error(`hours() must be set`);
            }
            const timezone = (_a = this._timezone) !== null && _a !== void 0 ? _a : "UTC";
            const after = luxon.DateTime.fromJSDate((_b = options.after) !== null && _b !== void 0 ? _b : new Date(0));
            const intervals = [this._dates]
                // if a callback is provided to dates(), get the returned value
                .map((valueOrCb) => valueOrCallback(valueOrCb, data))
                // if a single date is provided, convert to array
                .flatMap(toArray)
                // convert to luxon.Interval
                .map(toInterval)
                // break down into individual days
                .flatMap(toDays)
                // augment intervals with hours
                .flatMap((dateTime) => 
            // if a callback is provided to hours(), get the returned value
            [valueOrCallback(this._hours, data, dateTime.toFormat("yyyy-MM-dd"))]
                // if no hours or a single range was provided, convert to array
                .flatMap(toArray)
                // augment intervals with hours
                .map((hours) => withHours(dateTime, hours)))
                // augment intervals with timezone
                .map((interval) => withTimezone(interval, valueOrCallback(timezone, data)))
                // correct for the `after` value
                .map((interval) => interval.mapEndpoints((endpoint) => luxon.DateTime.max(endpoint, after)))
                // filter out empty intervals
                .filter((interval) => !interval.isEmpty());
            if (intervals.length === 0) {
                throw new Error(`no suitable intervals for job`);
            }
            const interval = intervals
                // get the interval with the earliest start time
                .reduce((acc, interval) => (acc.start < interval.start ? acc : interval));
            return {
                ...data,
                notBefore: interval.start.toJSDate(),
                notAfter: interval.end.toJSDate(),
            };
        });
    }
}
exports.default = Scheduler;
//# sourceMappingURL=scheduler.js.map