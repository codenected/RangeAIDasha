"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TranscriptionParser = void 0;
const isObject = (x) => typeof x === "object" && x !== null;
class TranscriptionParser {
    constructor(callback) {
        this.callback = callback;
        this.outgoing = { state: "initial" };
        this.incomingVoiceSegments = new Map();
    }
    push(logContent) {
        var _a, _b, _c;
        if (!isObject(logContent))
            return;
        if (typeof logContent.time !== "string")
            return;
        const { msg } = logContent;
        if (!isObject(msg))
            return;
        if ("voiceSegmentId" in msg) {
            const state = this.incomingVoiceSegments.get(msg.voiceSegmentId);
            switch (state === null || state === void 0 ? void 0 : state.state) {
                case undefined:
                    if (msg.msgId === "SpeechChannelMessage" && msg.type === "Voice") {
                        this.incomingVoiceSegments.set(msg.voiceSegmentId, {
                            state: "voice",
                            startTime: new Date(logContent.time),
                        });
                    }
                    break;
                case "voice":
                    if (msg.textMsgId === "FinalTextChannelMessage") {
                        this.incomingVoiceSegments.set(msg.voiceSegmentId, {
                            state: "final",
                            startTime: state.startTime,
                            text: String(msg.text),
                        });
                    }
                    if (msg.msgId === "SpeechChannelMessage" && msg.type === "Pause") {
                        this.incomingVoiceSegments.set(msg.voiceSegmentId, {
                            state: "pause",
                            startTime: state.startTime,
                            endTime: new Date(logContent.time),
                        });
                    }
                    break;
                case "final":
                    if (msg.msgId === "SpeechChannelMessage" && msg.type === "Pause") {
                        this.incomingVoiceSegments.delete(msg.voiceSegmentId);
                        (_a = this.callback) === null || _a === void 0 ? void 0 : _a.call(this, {
                            incoming: true,
                            startTime: state.startTime,
                            endTime: new Date(logContent.time),
                            text: state.text,
                        });
                    }
                    break;
                case "pause":
                    if (msg.textMsgId === "ConfidentTextChannelMessage") {
                        this.incomingVoiceSegments.delete(msg.voiceSegmentId);
                        (_b = this.callback) === null || _b === void 0 ? void 0 : _b.call(this, {
                            incoming: true,
                            startTime: state.startTime,
                            endTime: state.endTime,
                            text: String(msg.text),
                        });
                    }
                    break;
            }
        }
        switch (this.outgoing.state) {
            case "initial":
                if (msg.msgId === "RawTextChannelMessage" && logContent.incoming === false) {
                    this.outgoing = {
                        state: "text",
                        text: String(msg.text),
                        startTime: new Date(logContent.time),
                    };
                }
                break;
            case "text":
                if (msg.msgId === "StoppedPlayingAudioChannelMessage") {
                    (_c = this.callback) === null || _c === void 0 ? void 0 : _c.call(this, {
                        incoming: false,
                        text: this.outgoing.text,
                        startTime: this.outgoing.startTime,
                        endTime: new Date(logContent.time),
                    });
                    this.outgoing = { state: "initial" };
                }
                break;
        }
    }
}
exports.TranscriptionParser = TranscriptionParser;
//# sourceMappingURL=transcription.js.map