"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DashaSdk = exports.configure = void 0;
const fs = __importStar(require("fs"));
const stream_1 = require("stream");
const util_1 = require("util");
const archiver_1 = __importDefault(require("archiver"));
const axios_1 = __importDefault(require("axios"));
const grpc = __importStar(require("@grpc/grpc-js"));
const rxjs = __importStar(require("rxjs"));
// we can not import it in ts-style because the package is not into TS rootDir
// if you know
// eslint-disable-next-line @typescript-eslint/no-var-requires
const packageJson = require("../package.json");
//#region generated code imports
const external_client_tts_pb_1 = require("./generated/external-client-tts_pb");
const external_client_tts_grpc_pb_1 = require("./generated/external-client-tts_grpc_pb");
const nlu_service_grpc_pb_1 = require("./generated/nlu-service_grpc_pb");
const sdk_pb_1 = require("./generated/sdk_pb");
const sdk_grpc_pb_1 = require("./generated/sdk_grpc_pb");
//#endregion
const errors_1 = require("./errors");
const group_settings_1 = require("./group-settings");
const nlu_service_1 = require("./nlu-service");
const sip_settings_1 = require("./sip-settings");
const tts_1 = require("./tts");
const transcription_1 = require("./transcription");
const logger = __importStar(require("./logger"));
function configure(options) {
    logger.configure(options);
}
exports.configure = configure;
/**
 * @todo: add link
 */
class DashaSdk {
    /**
     * @param options.server Dasha platform server to use
     * @param options.url Deprecated. Use `options.server` instead.
     * @param options.apiKey API key of the Dasha platform.
     * @param options.insecure Set to true to not use TLS
     */
    constructor(options) {
        var _a, _b;
        // TODO: remove deprecated `options.url`
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        this.server = (_a = options.server) !== null && _a !== void 0 ? _a : options.url;
        this.apiKey = options.apiKey;
        this.insecure = (_b = options.insecure) !== null && _b !== void 0 ? _b : false;
        this.sipSettings = new sip_settings_1.SipSettingsManager({ ...options, server: this.server });
        this.groupSettings = new group_settings_1.GroupSettingsManager({ ...options, server: this.server });
        this.tts = new tts_1.TtsManager({ ...options, server: this.server });
    }
    async registerApp(options) {
        return logger.catchErrorsAsync(logger.create(), async () => {
            var _a, _b;
            const appPackage = (_a = options.appPackage) !== null && _a !== void 0 ? _a : (await makeZipArchive(options.appPackagePath));
            const client = this.createClient(sdk_grpc_pb_1.ProcessingClient);
            const externalTtsClient = this.createClient(external_client_tts_grpc_pb_1.ExternalClientTtsProtocolClient);
            const request = new sdk_pb_1.RegisterRequest();
            request.setApp(appPackage);
            request.setConcurrency(options.concurrency);
            request.setSdkVersion(`node:${(_b = packageJson.version) !== null && _b !== void 0 ? _b : "unknown"}`);
            if (options.groupId !== undefined)
                request.setGroupid(options.groupId);
            const instanceStream = client.registerInstanceStream(request);
            const rx = streamToRx(instanceStream);
            const progressReporter = options.progressReporter;
            if (progressReporter !== undefined) {
                const subscription = rx.subscribe((streamEvent) => {
                    const { progress, success, error } = streamEvent.toObject();
                    if (success !== undefined && error !== undefined) {
                        subscription.unsubscribe();
                        return;
                    }
                    if (progress === undefined)
                        return;
                    const event = {
                        stage: progress.stageDescription,
                        scope: progress.stageScopeList,
                        percent: progress.percent,
                    };
                    progressReporter(event);
                });
            }
            return new Promise((resolve, reject) => {
                const subscription = rx.subscribe((streamEvent) => {
                    const { success, error } = streamEvent.toObject();
                    if (error !== undefined) {
                        reject(new errors_1.DashaSdkError(error.errorDetails));
                        subscription.unsubscribe();
                        return;
                    }
                    if (success !== undefined) {
                        resolve(new Application(client, instanceStream, externalTtsClient, success.appId, success.instanceId));
                        subscription.unsubscribe();
                        return;
                    }
                }, (error) => {
                    reject(errors_1.DashaSdkError.fromGrpcServiceError(error));
                });
            });
        });
    }
    /**
     * Provide a chat connection for a specific job.
     *
     * @param platformJobId Platform-assigned ID of a job.
     *
     * @example
     * ```ts
     * const job = await app.startJob(data);
     * const chat = await dasha.connectChat(job.platformJobId)
     * ```
     */
    async connectChat(platformJobId) {
        return logger.catchErrorsAsync(logger.create(), async () => {
            const client = this.createClient(sdk_grpc_pb_1.TextProtocolClient);
            return new ChatChannel(client, platformJobId);
        });
    }
    createNluService(customIntents) {
        return logger.catchErrors(logger.create(), () => {
            const client = this.createClient(nlu_service_grpc_pb_1.NluServiceClient);
            return new nlu_service_1.NluServiceCreationRequest(client, customIntents);
        });
    }
    async downloadRecord(record, destination) {
        return logger.catchErrorsAsync(logger.create(), async () => {
            const url = `https://dasha-call-records-public-beta.s3.amazonaws.com/${record.recordId}/call.mp3`;
            const stream = typeof destination === "string" ? fs.createWriteStream(destination) : destination;
            const maxRetries = 10;
            const needsRetrying = (status) => status === 403 || status === 404 || (500 <= status && status <= 599);
            try {
                for (let i = 0; i < maxRetries; i += 1) {
                    const response = await axios_1.default(url, { responseType: "stream", validateStatus: null });
                    if (response.status === 200) {
                        await util_1.promisify(stream_1.pipeline)(response.data, stream);
                        return;
                    }
                    if (!needsRetrying(response.status)) {
                        throw new Error(`${response.status} ${response.statusText}`);
                    }
                    await util_1.promisify(setTimeout)(5000);
                }
            }
            catch (error) {
                throw new errors_1.DashaSdkError(`Unable to download record: ${error.message}`, error);
            }
            throw new errors_1.DashaSdkError(`Unable to download record: retry limit exceeded`);
        });
    }
    createClient(Client) {
        const metadata = new grpc.Metadata();
        metadata.add("Authorization", "Bearer " + this.apiKey);
        if (this.insecure) {
            return new Client(this.server, grpc.credentials.createInsecure(), {
                callInvocationTransformer: (callProperties) => {
                    callProperties.metadata.merge(metadata);
                    return callProperties;
                },
                "grpc.keepalive_time_ms": 10000,
            });
        }
        else {
            const creds = grpc.credentials.createFromMetadataGenerator((_, cb) => cb(null, metadata));
            return new Client(this.server, grpc.credentials.createSsl().compose(creds), {
                "grpc.keepalive_time_ms": 10000,
            });
        }
    }
}
exports.DashaSdk = DashaSdk;
class ChatChannel {
    /** @internal */
    constructor(client, jobId) {
        this.closed = false;
        this.subject = new rxjs.Subject();
        this.client = client;
        this.jobId = jobId;
        const streamInit = new sdk_pb_1.TextProtocolStreamInit();
        streamInit.setJobId(jobId);
        this.stream = client.messageStream(streamInit);
        streamToRx(this.stream).subscribe(async (message) => {
            const text = message.getText();
            if (text !== undefined) {
                this.subject.next(text.getText());
            }
        }, (error) => {
            this.closed = true;
            this.subject.error(errors_1.DashaSdkError.fromGrpcServiceError(error));
            this.client.close();
        }, () => {
            this.closed = true;
            this.subject.complete();
            this.client.close();
        });
    }
    get receivedMessages() {
        return this.subject.asObservable();
    }
    send(message) {
        return new Promise((resolve, reject) => {
            this.client.sendMessage(message, (error) => {
                if (error) {
                    const sdkError = errors_1.DashaSdkError.fromGrpcServiceError(error);
                    reject(sdkError);
                    this.subject.error(sdkError);
                    this.stream.cancel();
                }
                resolve();
            });
        });
    }
    async sendMessage(message) {
        return logger.catchErrorsAsync(logger.create(), async () => {
            if (this.closed) {
                return;
            }
            const grpcMessage = new sdk_pb_1.TextProtocolMessage();
            grpcMessage.setJobId(this.jobId);
            grpcMessage.setText(new sdk_pb_1.TextMessage().setText(message));
            await this.send(grpcMessage);
        });
    }
    async close() {
        return logger.catchErrorsAsync(logger.create(), async () => {
            if (this.closed) {
                return;
            }
            this.closed = true;
            const grpcMessage = new sdk_pb_1.TextProtocolMessage();
            grpcMessage.setJobId(this.jobId);
            grpcMessage.setClosed(new sdk_pb_1.ClosedSessionMessage());
            await this.send(grpcMessage);
        });
    }
}
function toUnixTime(date) {
    return Math.floor(+date / 1000);
}
async function makeZipArchive(path) {
    // sadly, archiver does not check the existence of `path`
    try {
        await fs.promises.stat(path);
    }
    catch (error) {
        throw new errors_1.DashaSdkError(`Error uploading application: ${error.message}.\nIs the path correct?`, error);
    }
    return new Promise((resolve, reject) => {
        const archive = archiver_1.default("zip");
        const chunks = [];
        archive.on("warning", (error) => reject(wrapArchiverError(error)));
        archive.on("error", (error) => reject(wrapArchiverError(error)));
        archive.on("data", (chunk) => chunks.push(chunk));
        archive.on("finish", () => resolve(Buffer.concat(chunks)));
        archive.directory(path, false);
        archive.finalize().catch((error) => reject(wrapArchiverError(error)));
    });
}
function zipSingleFile(path, content) {
    return new Promise((resolve, reject) => {
        const archive = archiver_1.default("zip");
        const chunks = [];
        archive.on("warning", (error) => reject(wrapArchiverError(error)));
        archive.on("error", (error) => reject(wrapArchiverError(error)));
        archive.on("data", (chunk) => chunks.push(chunk));
        archive.on("finish", () => resolve(Buffer.concat(chunks)));
        archive.append(content, { name: path });
        archive.finalize().catch((error) => reject(wrapArchiverError(error)));
    });
}
function wrapArchiverError(error) {
    return new errors_1.DashaSdkError(`Error registering application: ${error}`, error);
}
function streamToRx(stream) {
    return new rxjs.Observable((subscriber) => {
        const dataHandler = (data) => subscriber.next(data);
        const endHandler = () => subscriber.complete();
        const errorHandler = (e) => {
            // we should not complain if we are the ones to cancel
            if (e.code === grpc.status.CANCELLED) {
                return;
            }
            subscriber.error(e);
        };
        stream.on("data", dataHandler);
        stream.on("end", endHandler);
        stream.on("error", errorHandler);
        stream.on("removeListener", (listener) => {
            if (listener === dataHandler)
                subscriber.complete();
        });
        return () => {
            stream.removeListener("data", dataHandler);
            stream.removeListener("end", endHandler);
            stream.removeListener("error", errorHandler);
        };
    });
}
class Application {
    /** @internal */
    constructor(processingClient, instanceStream, externalTtsClient, applicationId, instanceId) {
        this._errors = new rxjs.Subject();
        this.errors = this._errors.asObservable();
        this.jobHandlers = new Map();
        this.defaultTtsHandler = () => {
            return Promise.reject(new Error("TTS handler is not set"));
        };
        this._logger = logger.create({ applicationId, instanceId });
        this.processingClient = processingClient;
        this.instanceStream = instanceStream;
        this.externalTtsClient = externalTtsClient;
        this.applicationId = applicationId;
        this.instanceId = instanceId;
        const streamInit = new sdk_pb_1.StreamInit();
        streamInit.setInstanceId(this.instanceId);
        this.runtimeStream = this.processingClient.runtimeStream(streamInit);
        streamToRx(this.runtimeStream).subscribe((message) => this.onRuntimeMessage(message), this.subscribeErrorHandler(`Runtime stream error`));
        this.debugStream = this.processingClient.debugStream(streamInit);
        streamToRx(this.debugStream).subscribe((message) => this.onDebugMessage(message), this.subscribeErrorHandler(`Debug stream error`));
        this.ttsHandler = this.defaultTtsHandler;
        const externalClientStreamInit = new external_client_tts_pb_1.ExternalClientTtsProtocolStreamInit();
        externalClientStreamInit.setInstanceId(instanceId);
        this.externalClientStream = this.externalTtsClient.audioRequestStream(externalClientStreamInit);
        streamToRx(this.externalClientStream).subscribe((message) => this.onExternalClientMessage(message), this.subscribeErrorHandler(`External client stream error`));
    }
    subscribeErrorHandler(errorMessage) {
        return async (error) => {
            this._logger.error(errorMessage, error);
            this._errors.next(errors_1.DashaSdkError.fromGrpcServiceError(error));
        };
    }
    setTtsHandler(handler) {
        if (handler !== undefined) {
            this.ttsHandler = handler;
        }
        else {
            this.ttsHandler = this.defaultTtsHandler;
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    setLogger(logger) {
        // no-op
    }
    disconnect() {
        return logger.catchErrors(this._logger, () => {
            this.instanceStream.cancel();
            this.runtimeStream.cancel();
            this.debugStream.cancel();
            this.externalClientStream.cancel();
            this.processingClient.close();
            this.externalTtsClient.close();
        });
    }
    async addSessionConfig(options) {
        return logger.catchErrorsAsync(this._logger, async () => {
            const archive = options.config
                ? await zipSingleFile("config.json", JSON.stringify(options.config))
                : await makeZipArchive(options.configPath);
            const request = new sdk_pb_1.AddSessionConfigRequest();
            request.setConfig(archive);
            if (options.name !== undefined)
                request.setConfigName(options.name);
            request.setInstanceId(this.instanceId);
            return new Promise((resolve, reject) => this.processingClient.addSessionConfig(request, (error, response) => {
                if (error) {
                    reject(errors_1.DashaSdkError.fromGrpcServiceError(error));
                }
                else {
                    resolve(response.getConfigName());
                }
            }));
        });
    }
    enqueueJobs(jobs) {
        return logger.catchErrorsAsync(this._logger, async () => {
            for (const job of jobs) {
                if (job.priority !== undefined) {
                    errors_1.DashaSdkError.assertUint32(job.priority, `job priority must be convertible to uint32`);
                }
            }
            const now = new Date();
            const request = new sdk_pb_1.EnqueueJobRequest();
            request.setInstanceId(this.instanceId);
            request.setJobsList(jobs.map((job) => {
                var _a, _b;
                return new sdk_pb_1.JobDescription()
                    .setJobId(job.id)
                    .setPriority((_a = job.priority) !== null && _a !== void 0 ? _a : 0)
                    .setNotBefore(toUnixTime((_b = job.notBefore) !== null && _b !== void 0 ? _b : now))
                    .setNotAfter(toUnixTime(job.notAfter));
            }));
            return new Promise((resolve, reject) => this.processingClient.enqueueJob(request, (error) => {
                if (error) {
                    reject(errors_1.DashaSdkError.fromGrpcServiceError(error));
                }
                else {
                    resolve();
                }
            }));
        });
    }
    onJob(jobEventHandler) {
        return streamToRx(this.instanceStream).subscribe(async (event) => {
            const notification = event.toObject().jobNotification;
            if (notification === undefined) {
                return;
            }
            try {
                await this.onJobStatusNotification(jobEventHandler, notification.status, notification.customerJobId, notification.assignedJobId, JSON.parse(notification.data));
            }
            catch (error) {
                this._logger.error(error);
                this._errors.next(error);
            }
        }, (error) => {
            this._logger.error(error);
            this._errors.next(errors_1.DashaSdkError.fromGrpcServiceError(error));
            this._errors.complete();
        });
    }
    startJob(id, sessionConfigName, options) {
        return logger.catchErrorsAsync(this._logger, () => {
            return new Promise((resolveStart, rejectStart) => {
                const result = new Promise((resolveResult, rejectResult) => {
                    const records = new Promise((resolveRecords, rejectRecords) => {
                        this.onJob({
                            startingJob: async (internalId, jobId) => {
                                if (jobId === id) {
                                    resolveStart({
                                        internalId,
                                        id,
                                        result,
                                        records,
                                    });
                                    return { accept: true, sessionConfigName: sessionConfigName, ...options };
                                }
                                else {
                                    this._logger.warn(`Rejecting job with id ${jobId}: concurrent jobs are not supported with startJob().`, { jobId });
                                    return { accept: false };
                                }
                            },
                            completedJob: async (jobId, result, records) => {
                                if (jobId === id) {
                                    resolveResult(result);
                                    resolveRecords(records);
                                }
                            },
                            failedJob: async (jobId, error, records) => {
                                if (jobId === id) {
                                    rejectResult(error);
                                    resolveRecords(records);
                                }
                            },
                            timedOutJob: async (jobId) => {
                                if (jobId === id) {
                                    const error = new errors_1.DashaSdkError("job timed out");
                                    rejectStart(error);
                                    rejectResult(error);
                                    rejectRecords(error);
                                }
                            },
                        });
                        const deadline = new Date(Date.now() + 10 * 60 * 1000);
                        this.enqueueJobs([{ id, notAfter: deadline }]).catch((error) => {
                            rejectStart(error);
                            rejectResult(error);
                            rejectRecords(error);
                        });
                    });
                });
            });
        });
    }
    async onExternalClientMessage(message) {
        const voiceInfo = message.getVoiceInfo();
        const response = new external_client_tts_pb_1.ExternalClientTtsResponse();
        response.setRequestId(message.getRequestId());
        response.setMessageId(message.getMessageId());
        response.setInstanceId(this.instanceId);
        try {
            const handlerResponse = await this.ttsHandler(message.getText(), {
                speaker: voiceInfo.getSpeaker(),
                language: voiceInfo.getLang(),
                emotion: voiceInfo.getEmotion(),
                speed: voiceInfo.getSpeed(),
                variation: voiceInfo.getVariation(),
            });
            const successResponse = new external_client_tts_pb_1.ExternalClientTtsSuccessResponse();
            successResponse.setAudioFormat(handlerResponse.audioFormat);
            successResponse.setAudioData(handlerResponse.audioData);
            response.setSuccessResponse(successResponse);
        }
        catch (error) {
            const audioError = new external_client_tts_pb_1.ExternalClientTtsError();
            audioError.setDetails(error.stack);
            audioError.setMessage(error.message);
            audioError.setType("AudioHandlerError");
            response.setError(audioError);
            this._logger.error("TTS handler was not set at the time of a TTS response");
        }
        await this.sendExternalClientResponse(response);
    }
    sendExternalClientResponse(response) {
        return new Promise((resolve, reject) => this.externalTtsClient.sendAudio(response, (error) => {
            if (error) {
                reject(errors_1.DashaSdkError.fromGrpcServiceError(error));
            }
            else {
                resolve();
            }
        }));
    }
    async onRuntimeMessage(message) {
        try {
            const request = message.getRequest();
            if (request !== undefined) {
                await this.onRuntimeRequest(request);
            }
        }
        catch (error) {
            this._logger.error(error);
            this._errors.next(error);
        }
    }
    async onRuntimeRequest(request) {
        var _a, _b;
        const jobId = request.getJobId();
        const method = request.getMethod().split("/");
        const requestId = request.getRequestId();
        if (method[0] !== "graphCall") {
            this._logger.warn(`Unknown runtime request: "${method[0]}"`);
            return;
        }
        const handler = (_b = (_a = this.jobHandlers.get(jobId)) === null || _a === void 0 ? void 0 : _a.rpc) === null || _b === void 0 ? void 0 : _b[method[1]];
        if (!handler) {
            this._logger.warn(`RPC handler "${method}" not found`);
            await this.sendRuntimeError(jobId, requestId, "Handler not found");
            return;
        }
        const params = Object.fromEntries(request.getParametersList().map((p) => [p.getName(), JSON.parse(p.getValue())]));
        let result;
        try {
            result = await handler(params);
            if (result === undefined) {
                throw new Error(`Externall call '${method[1]}' called with params '${JSON.stringify(params)}' returned a forbidden 'undefined' value.`);
            }
        }
        catch (error) {
            this._logger.error(`Error in RPC handler "${method}: ${error.message}"`, error);
            await this.sendRuntimeError(jobId, requestId, String(error));
            return;
        }
        await this.sendRuntimeResponse(jobId, requestId, result);
    }
    async onDebugMessage(message) {
        try {
            const notification = message.getNotification();
            if (notification !== undefined) {
                await this.onDebugNotification(notification);
            }
        }
        catch (error) {
            this._logger.error(error);
            this._errors.next(error);
        }
    }
    async onDebugNotification(notification) {
        var _a, _b, _c, _d;
        const jobId = notification.getJobId();
        const handler = this.jobHandlers.get(jobId);
        if (!(handler === null || handler === void 0 ? void 0 : handler.debug)) {
            return;
        }
        const method = notification.getMethod();
        const params = Object.fromEntries(notification.getParametersList().map((p) => [p.getName(), JSON.parse(p.getValue())]));
        switch (method) {
            case "jobEvent": {
                handler.transcriptionParser.push(params.content);
                if (params.content.msg.msgId === "ClosedSessionChannelMessage" && params.content.msg.callId) {
                    handler.records.push({ recordId: params.content.msg.callId });
                }
                try {
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    await ((_b = (_a = handler.debug) === null || _a === void 0 ? void 0 : _a.raw) === null || _b === void 0 ? void 0 : _b.call(_a, params.content));
                }
                catch (error) {
                    this._logger.error(`Error in raw log handler: ${error.message}`, error);
                }
                break;
            }
            case "debugLog":
                try {
                    await ((_d = (_c = handler.debug).log) === null || _d === void 0 ? void 0 : _d.call(_c, params.message));
                    break;
                }
                catch (error) {
                    this._logger.error(`Error in #log() syscall handler: ${error.message}`, error);
                }
        }
    }
    async onJobStatusNotification(handler, status, customerId, assignedId, data) {
        var _a, _b, _c, _d, _e;
        switch (status) {
            case sdk_pb_1.JobNotification.JobStatus.STARTING: {
                let startingResult;
                try {
                    startingResult = await handler.startingJob(assignedId, customerId, data !== null && data !== void 0 ? data : {});
                }
                catch (error) {
                    this._logger.error(`Error in "startingJob" handler for id "${customerId}": ${error.message}, rejecting this job`, error);
                    await this.rejectJob(assignedId);
                    break;
                }
                if (!startingResult.accept) {
                    await this.rejectJob(assignedId);
                    break;
                }
                if (startingResult.rpcHandler || startingResult.debugEvents) {
                    const { rpcHandler, debugEvents } = startingResult;
                    this.jobHandlers.set(assignedId, {
                        rpc: rpcHandler,
                        debug: debugEvents,
                        records: [],
                        transcriptionParser: new transcription_1.TranscriptionParser(async (ts) => {
                            var _a;
                            try {
                                await ((_a = debugEvents === null || debugEvents === void 0 ? void 0 : debugEvents.transcription) === null || _a === void 0 ? void 0 : _a.call(debugEvents, ts.text, ts.incoming, ts));
                            }
                            catch (error) {
                                this._logger.error(`Error in debug log handler for id "${customerId}"`, error);
                            }
                        }),
                    });
                }
                await this.acceptJob(assignedId, startingResult.sessionConfigName, startingResult.data);
                break;
            }
            case sdk_pb_1.JobNotification.JobStatus.TIMED_OUT:
                try {
                    await ((_a = handler.timedOutJob) === null || _a === void 0 ? void 0 : _a.call(handler, customerId));
                }
                catch (error) {
                    this._logger.error(`Error in "timedOutJob" handler for id "${customerId}": ${error.message}`, error);
                }
                finally {
                    this.jobHandlers.delete(assignedId);
                }
                break;
            case sdk_pb_1.JobNotification.JobStatus.FAILED: {
                const records = (_c = (_b = this.jobHandlers.get(assignedId)) === null || _b === void 0 ? void 0 : _b.records) !== null && _c !== void 0 ? _c : [];
                try {
                    await handler.failedJob(customerId, new errors_1.DashaSdkError(String(data.msg)), records);
                }
                catch (error) {
                    this._logger.error(`Error in "failedJob" handler for id "${customerId}": ${error.message}`, error);
                }
                finally {
                    this.jobHandlers.delete(assignedId);
                }
                break;
            }
            case sdk_pb_1.JobNotification.JobStatus.COMPLETED: {
                const records = (_e = (_d = this.jobHandlers.get(assignedId)) === null || _d === void 0 ? void 0 : _d.records) !== null && _e !== void 0 ? _e : [];
                try {
                    await handler.completedJob(customerId, data, records);
                }
                catch (error) {
                    this._logger.error(`Error in "completedJob" handler for id "${customerId}": ${error.message}`, error);
                }
                finally {
                    this.jobHandlers.delete(assignedId);
                }
                break;
            }
        }
    }
    acceptJob(jobId, sessionConfigName, data) {
        const request = new sdk_pb_1.AcceptJobMessage();
        request.setInstanceId(this.instanceId);
        request.setJobId(jobId);
        request.setSessionConfigName(sessionConfigName);
        request.setData(JSON.stringify(data));
        return new Promise((resolve, reject) => this.processingClient.acceptJob(request, (error) => {
            if (error) {
                reject(errors_1.DashaSdkError.fromGrpcServiceError(error));
            }
            else {
                resolve();
            }
        }));
    }
    rejectJob(jobId) {
        const request = new sdk_pb_1.RejectJobMessage();
        request.setInstanceId(this.instanceId);
        request.setJobId(jobId);
        return new Promise((resolve, reject) => this.processingClient.rejectJob(request, (error) => {
            if (error) {
                reject(errors_1.DashaSdkError.fromGrpcServiceError(error));
            }
            else {
                resolve();
            }
        }));
    }
    sendRuntimeResponse(jobId, requestId, result) {
        const response = new sdk_pb_1.StreamResponse();
        response.setJobId(jobId);
        response.setRequestId(requestId);
        response.setResult(JSON.stringify(result));
        const clientStreamMessage = new sdk_pb_1.ClientStreamMessage();
        clientStreamMessage.setInstanceId(this.instanceId);
        clientStreamMessage.setMessage(new sdk_pb_1.StreamMessage().setResponse(response));
        return new Promise((resolve, reject) => this.processingClient.sendRuntimeMessage(clientStreamMessage, (error) => {
            if (error) {
                reject(errors_1.DashaSdkError.fromGrpcServiceError(error));
            }
            else {
                resolve();
            }
        }));
    }
    sendRuntimeError(jobId, requestId, message) {
        const error = new sdk_pb_1.StreamError();
        error.setJobId(jobId);
        error.setRequestId(requestId);
        error.setMessage(message);
        const clientStreamMessage = new sdk_pb_1.ClientStreamMessage();
        clientStreamMessage.setInstanceId(this.instanceId);
        clientStreamMessage.setMessage(new sdk_pb_1.StreamMessage().setError(error));
        return new Promise((resolve, reject) => this.processingClient.sendRuntimeMessage(clientStreamMessage, (error) => {
            if (error) {
                reject(errors_1.DashaSdkError.fromGrpcServiceError(error));
            }
            else {
                resolve();
            }
        }));
    }
}
//# sourceMappingURL=sdk.js.map